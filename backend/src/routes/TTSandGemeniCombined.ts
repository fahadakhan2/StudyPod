// src/routes/podcast.ts
import express, { Request, Response, Router } from 'express';
import { PodcastAudio } from '../types/PodcastAudio';
import { testGenerate } from '../types/testGenerate';
import { GoogleGenerativeAI } from '@google/generative-ai';
import * as PlayHT from 'playht';
import dotenv from 'dotenv';

dotenv.config();

// ——— Gemini setup ———
const geminiApiKey = process.env.GOOGLE_API_KEY;
if (!geminiApiKey) throw new Error('GOOGLE_API_KEY is not defined');
const googleAI = new GoogleGenerativeAI(geminiApiKey);
const geminiModel = googleAI.getGenerativeModel({
  model: 'gemini-2.0-flash',
});

// ——— PlayHT setup ———
PlayHT.init({
  userId: process.env.PLAYHT_USER_ID!,
  apiKey: process.env.PLAYHT_API_KEY!,
});

const router: Router = Router();

// If you still want to keep an in-memory record of audio/text, you can.
// Otherwise you can remove these.
let podcastAudios: PodcastAudio[] = [];
let geminiResp: testGenerate = { id: 0, content: '' };

// ----------------------------------------------------------------
// GET /generate-text?prompt=…
//   → returns JSON with generated text
// ----------------------------------------------------------------
router.get(
  '/generate-text',
  async (req: Request, res: Response): Promise<void> => {
    const prompt = String(req.query.prompt || '').trim();
    if (!prompt) {
      res.status(400).json({ error: 'prompt query parameter is required' });
      return;
    }

    try {
      // 1) Gemini → text
      const result = await geminiModel.generateContent(prompt);
      const text = await result.response.text();
      console.log('Gemini output:', text);

      // (Optional) store text + audio metadata in memory
      geminiResp = { id: geminiResp.id + 1, content: text };

      // Send the text content as JSON
      res.json({ test: text });
    } catch (err) {
      console.error('Error in /generate-text:', err);
      res.status(500).json({ error: 'Failed to generate text' });
    }
  }
);

// ----------------------------------------------------------------
// GET /generate-audio?prompt=…
//   → streams back an MP3 generated by PlayHT from Gemini's output
// ----------------------------------------------------------------
router.get(
  '/generate-audio',
  async (req: Request, res: Response): Promise<void> => {
    const prompt = String(req.query.prompt || '').trim();
    if (!prompt) {
      res.status(400).json({ error: 'prompt query parameter is required' });
      return;
    }

    try {
      // 1) Gemini → text
      const result = await geminiModel.generateContent(prompt);
      const text = await result.response.text();
      console.log('Gemini output:', text);

      // 2) PlayHT → stream, piped to the client
      res.setHeader('Content-Type', 'audio/mpeg');
      // res.setHeader('Content-Disposition', 'attachment; filename="generated.mp3"');

      const stream = await PlayHT.stream(text, {
        voiceEngine: 'PlayDialog',
      });
      for await (const chunk of stream) {
        res.write(chunk as Buffer);
      }
      res.end();
    } catch (err) {
      console.error('Error in /generate-audio:', err);
      if (!res.headersSent) {
        res.status(500).json({ error: 'Failed to generate TTS' });
      } else {
        res.end();
      }
    }
  }
);

export default router;
