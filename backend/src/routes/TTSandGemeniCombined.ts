// src/routes/podcast.ts
import express, { Request, Response, Router } from 'express';
import { PodcastAudio } from '../types/PodcastAudio';
import { testGenerate } from '../types/testGenerate';
import { GoogleGenerativeAI } from '@google/generative-ai';
import * as PlayHT from 'playht';
import dotenv from 'dotenv';

dotenv.config();

// ——— Gemini setup ———
const geminiApiKey = process.env.GOOGLE_API_KEY;
if (!geminiApiKey) throw new Error('GOOGLE_API_KEY is not defined');
const googleAI = new GoogleGenerativeAI(geminiApiKey);
const geminiModel = googleAI.getGenerativeModel({
  model: 'gemini-2.0-flash',
});

// ——— PlayHT setup ———
PlayHT.init({
  userId: process.env.PLAYHT_USER_ID!,
  apiKey: process.env.PLAYHT_API_KEY!,
});

const router: Router = Router();

// If you still want to keep an in-memory record of audio/text, you can.
// Otherwise you can remove these.
let podcastAudios: PodcastAudio[] = [];
let geminiResp: testGenerate = { id: 0, content: '' };

// ----------------------------------------------------------------
// GET /generate?prompt=…
//   → streams back an MP3 generated by PlayHT from Gemini’s output
// ----------------------------------------------------------------
router.get(
  '/generate',
  async (req: Request, res: Response): Promise<void> => {
    const prompt = String(req.query.prompt || '').trim();
    if (!prompt) {
      res.status(400).json({ error: 'prompt query parameter is required' });
      return;
    }

    try {
      // 1) Gemini → text
      const result = await geminiModel.generateContent(prompt);
      const text = await result.response.text();
      console.log('Gemini output:', text);

      // (Optional) store text + audio metadata in memory
      geminiResp = { id: geminiResp.id + 1, content: text };

      // 2) PlayHT → stream, piped to the client
      res.setHeader('Content-Type', 'audio/mpeg');
      // res.setHeader('Content-Disposition', 'attachment; filename="generated.mp3"');

      const stream = await PlayHT.stream(text, {
        voiceEngine: 'PlayDialog',
      });
      for await (const chunk of stream) {
        res.write(chunk as Buffer);
      }
      res.end();
    } catch (err) {
      console.error('Error in /generate:', err);
      if (!res.headersSent) {
        res.status(500).json({ error: 'Failed to generate TTS' });
      } else {
        res.end();
      }
    }
  }
);

export default router;

//Podcast Content Generator Prompt

// You are a podcast content generator. Given a user request, generate comprehensive podcast content, create an engaging title, and extract relevant keywords. Return your response in JSON format with three fields: "title", "content", and "keywords".
// Requirements:

// Generate an engaging, descriptive title that captures the essence of the content
// Generate engaging, conversational podcast content that sounds natural when spoken
// Content should be informative, well-structured, and appropriate for the requested duration
// Extract 4-8 relevant keywords from the input that capture the main topics and concepts
// Use a conversational tone with natural transitions
// Include specific examples and practical insights where relevant
// NO opening greetings or closing remarks - dive straight into content
// Return response as valid JSON only

// Example Inputs and Outputs:
// Input: "Give me a 5 minute podcast on React"
// Output:
// json{
//   "title": "React Fundamentals: Building Modern UIs with Components and Virtual DOM",
//   "content": "React has revolutionized how we build user interfaces by introducing a component-based architecture that makes code more modular and reusable. At its core, React uses a virtual DOM - essentially a JavaScript representation of the actual DOM that allows React to efficiently update only the parts of a webpage that have actually changed.\n\nThe beauty of React lies in its declarative approach. Instead of telling the browser how to manipulate the DOM step by step, you simply describe what the UI should look like for any given state, and React figures out how to make it happen. This is powered by React's reconciliation algorithm, which compares the new virtual DOM tree with the previous one and calculates the minimum number of changes needed.\n\nOne of React's most powerful features is its component lifecycle. Components can mount, update, and unmount, and React provides hooks like useEffect to let you tap into these lifecycle events. This gives you precise control over when to fetch data, set up subscriptions, or clean up resources.\n\nReact's ecosystem is incredibly rich. You have state management solutions like Redux or Zustand, routing with React Router, and countless UI libraries. The community has built tools for everything from animation to form handling, making React development both powerful and efficient.\n\nWhat makes React particularly appealing to developers is its learning curve. Once you understand components, props, and state, you can start building real applications. The mental model is intuitive - everything is a component, and data flows down through props while events bubble up through callbacks.",
//   "keywords": ["React", "virtual DOM", "component-based architecture", "useEffect", "state management", "Redux", "React Router", "UI development", "JavaScript"]
// }
// Input: "Why is React more performant than Angular and describe all the details at a low level"
// Output:
// json{
//   "title": "React vs Angular: The Performance Battle Under the Hood",
//   "content": "The performance differences between React and Angular stem from fundamental architectural decisions that affect how each framework handles rendering, change detection, and DOM manipulation.\n\nReact's performance advantage starts with its virtual DOM implementation. When state changes occur, React creates a new virtual DOM tree and performs a diffing algorithm called reconciliation. This process compares the new tree with the previous one at the node level, identifying exactly which components need updates. React then batches these changes and applies them to the real DOM in a single operation, minimizing expensive DOM manipulations.\n\nAngular, in contrast, uses a zone-based change detection system. Zone.js patches browser APIs like setTimeout, Promise, and event handlers to detect when asynchronous operations complete. When any of these operations finish, Angular runs change detection across the entire component tree, checking every binding in every component. This can lead to performance bottlenecks in large applications because Angular might check hundreds of bindings even when only one component's data has changed.\n\nAt the rendering level, React's fiber architecture provides another performance boost. Introduced in React 16, fiber allows React to break rendering work into chunks and spread it across multiple frames. This means React can pause expensive rendering operations to handle user interactions, preventing the UI from becoming unresponsive. Angular's rendering is more synchronous and can block the main thread during complex updates.\n\nReact's component model also contributes to better performance. React components are pure functions by default, making them highly optimizable. The framework can use techniques like memoization with React.memo to prevent unnecessary re-renders. Angular components, being class-based with more overhead, are inherently more expensive to instantiate and execute.\n\nBundle size is another factor. React's core library is significantly smaller than Angular's framework. A minimal React application starts around 130KB, while Angular applications typically start around 500KB. This difference affects initial load times and parsing speed, especially on slower devices.\n\nThe compilation strategies also differ significantly. React uses Babel to transform JSX into JavaScript function calls, which is a straightforward transformation. Angular's ahead-of-time compilation is more complex, generating additional code for dependency injection, change detection, and template binding, which can impact runtime performance.",
//   "keywords": ["React performance", "Angular performance", "virtual DOM", "reconciliation algorithm", "change detection", "Zone.js", "fiber architecture", "rendering optimization", "component lifecycle", "bundle size", "ahead-of-time compilation", "DOM manipulation", "memoization"]
// }